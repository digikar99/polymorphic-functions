* About
  :PROPERTIES:
  :CUSTOM_ID: polymorphic-functions
  :END:

#+BEGIN_QUOTE
  This library is still experimental. Interface can change in
  backward-incompatible ways. Please wait until a proper release to use
  in production code. (Or track commits and use git submodules and/or
  qlot!)

  If you would like at least a few grams (or ounce :p) of stability,
  stick to the following symbols: 
  
  - define-polymorphic-function
  - undefine-polymorphic-function
  - defpolymorph
  - defpolymorph-compiler-macro
  - undefpolymorph
  - find-polymorph
#+END_QUOTE

The library provides all of

- [[https://en.wikipedia.org/wiki/Ad_hoc_polymorphism][Ad hoc
  polymorphism]] and
- [[https://en.wikipedia.org/wiki/Subtyping][Subtype Polymorphism]]
- [[https://en.wikipedia.org/wiki/Parametric_polymorphism][Parametric
  Polymorphism]]

to dispatch and/or optimize on the basis of types rather than classes.

* Table of Contents
:PROPERTIES:
:TOC: :include all
:END:

:CONTENTS:
- [[#about][About]]
- [[#table-of-contents][Table of Contents]]
- [[#usage][Usage]]
  - [[#basic-usage][Basic Usage]]
    - [[#examples][Examples]]
  - [[#libraries--projects-currently-using-polymorphic-functions][Libraries / Projects currently using polymorphic-functions]]
  - [[#static-dispatch--inline-optimizations][Static Dispatch / Inline Optimizations]]
  - [[#advanced-usage][Advanced Usage]]
    - [[#parametric-polymorphism][Parametric Polymorphism]]
    - [[#extended-types][Extended Types]]
  - [[#limitations][Limitations]]
- [[#rationale][Rationale]]
- [[#dependencies-outside-quicklisp][Dependencies outside quicklisp]]
  - [[#getting-it-from-ultralisp][Getting it from ultralisp]]
  - [[#getting-it-from-clpm][Getting it from clpm]]
- [[#tests][Tests]]
- [[#related-projects][Related Projects]]
- [[#feature-parity][Feature Parity]]
- [[#acknowledgements][Acknowledgements]]
:END:


* Usage
   :PROPERTIES:
   :CUSTOM_ID: usage
   :END:

** Basic Usage
    :PROPERTIES:
    :CUSTOM_ID: basic-usage
    :END:

- Users are expected to define a =polymorphic-function= (analogous to
  =cl:generic-function=) with one or more =polymorph= (similar to
  =cl:method=). These may be dispatched at runtime or at compile time if
  optimization policy is =(and (= speed 3) (/= debug 3))= abbreviated as
  =optim-speed=.
- Adhoc Polymorphism is supported in the sense that different polymorphs
  can have different implementations.
- Subtype Polymorphism is supported in the sense that once a polymorph
  is defined, then when a call to it is being compiled, then the type
  declarations inside the lambda-body of the polymorph are enhanced
  using the more specific type declarations in the environment. Thus, a
  polymorph that was defined for =vector= when compiled with arguments
  declared to be =simple-string=, then the body is made aware at
  /compiler/macroexpansion time/ that the arguments are actually
  =simple-string= rather than just =vector=. Code further in the
  succeeding compiler/macroexpansion phases can then make use of this
  information.
- Individual polymorphs may also additionally have compiler macros.
  However, the policy under which these may be invoked is undefined. In
  essence, user code must not rely on compiler macros for /correctness/.
- See [[#advanced-usage-aka-parametric-polymorphism][Advanced Usage]]
  for parametric polymorphism. Adhoc and Subtype polymorphisms should
  suffice in most cases for optimization; parametric polymorphism can
  aid in further type safety.

*** Examples
     :PROPERTIES:
     :CUSTOM_ID: examples
     :END:

See [[file:src/misc-tests.lisp]] for some more examples.

#+BEGIN_SRC lisp
  (use-package :polymorphic-functions)
  (define-polymorphic-function my= (a b))
  (defpolymorph my= ((a string) (b string)) boolean
    (string= a b))
  (defpolymorph my= ((a character) (b character)) boolean
    (char= a b))
  (defpolymorph my= ((a (simple-array single-float))
                    (b (simple-array single-float))) symbol
    ;; possible here; not possible with cl:defmethod without some MOP-fu
    ;; do something
    'hello)
#+END_SRC

#+BEGIN_SRC lisp
  CL-USER> (defun foo (a b)
             (declare (optimize speed)
                      (type string a b))
             (string= a b))

  FOO
  CL-USER> (disassemble 'foo)
  ; disassembly for FOO
  ; Size: 39 bytes. Origin: #x5300D1B3                          ; FOO
  ; B3:       31F6             XOR ESI, ESI
  ; B5:       48C745F017011050 MOV QWORD PTR [RBP-16], #x50100117  ; NIL
  ; BD:       488975E8         MOV [RBP-24], RSI
  ; C1:       48C745E017011050 MOV QWORD PTR [RBP-32], #x50100117  ; NIL
  ; C9:       B90C000000       MOV ECX, 12
  ; CE:       FF7508           PUSH QWORD PTR [RBP+8]
  ; D1:       B8E25A3550       MOV EAX, #x50355AE2              ; #<FDEFN SB-KERNEL:STRING=*>
  ; D6:       FFE0             JMP RAX
  ; D8:       CC10             INT3 16                          ; Invalid argument count trap
  NIL
  CL-USER> (defun bar (a b)
             (declare (optimize speed)
                      (type string a b))
             (my= a b))
  BAR
  CL-USER> (disassemble 'bar)
  ; disassembly for BAR
  ; Size: 39 bytes. Origin: #x5300D283                          ; BAR
  ; 83:       31F6             XOR ESI, ESI
  ; 85:       48C745F017011050 MOV QWORD PTR [RBP-16], #x50100117  ; NIL
  ; 8D:       488975E8         MOV [RBP-24], RSI
  ; 91:       48C745E017011050 MOV QWORD PTR [RBP-32], #x50100117  ; NIL
  ; 99:       B90C000000       MOV ECX, 12
  ; 9E:       FF7508           PUSH QWORD PTR [RBP+8]
  ; A1:       B8E25A3550       MOV EAX, #x50355AE2              ; #<FDEFN SB-KERNEL:STRING=*>
  ; A6:       FFE0             JMP RAX
  ; A8:       CC10             INT3 16                          ; Invalid argument count trap
  NIL
  CL-USER> (my= (make-array 1 :element-type 'single-float)
                (make-array 1 :element-type 'single-float))
  HELLO
  CL-USER> (defun baz (a b)
             (declare (type string a)
                      (type integer b)
                      (optimize safety))
             (my= a b))
  ; While compiling
  ;     (MY= A B)
  ;   Following notes were encountered:
  ;
  ;     No applicable POLYMORPH discovered for polymorphic-function
  ;       MY=
  ;     and ARG-LIST:
  ;
  ;       (A B)
  ;
  ;     Available Effective-Type-Lists include:
  ;
  ;       (STRING STRING)
  ;       (CHARACTER CHARACTER)
  ;       ((SIMPLE-ARRAY SINGLE-FLOAT) (SIMPLE-ARRAY SINGLE-FLOAT))
  BAZ
  CL-USER> (my= 5 "hello")
  ; Evaluation aborted on #<POLYMORPHIC-FUNCTIONS::NO-APPLICABLE-POLYMORPH/ERROR {103A713D13}>.
#+END_SRC

** Libraries / Projects currently using polymorphic-functions
    :PROPERTIES:
    :CUSTOM_ID: libraries-projects-currently-using-polymorphic-functions
    :END:

- [[https://github.com/digikar99/abstract-arrays][abstract-arrays]] and
  [[https://github.com/digikar99/dense-numericals/][dense-arrays]]
- [[https://github.com/digikar99/dense-numericals/][dense-numericals]]:
  this makes extensive use of subtype polymorphism to avoid code
  repetition in the /packaged/ provided code, cutting down on initial
  compile times.
- lisp-polymorph with currently working

  - [[https://github.com/lisp-polymorph/polymorph.maths][polymorph.maths]]
  - [[https://github.com/lisp-polymorph/polymorph.access][polymorph.access]]
  - [[https://github.com/lisp-polymorph/polymorph.copy-cast][polymorph.copy-cast]]
  - and more...

** Static Dispatch / Inline Optimizations
    :PROPERTIES:
    :CUSTOM_ID: static-dispatch-inline-optimizations
    :END:

A compiler-note-providing compiler-macro has also been provided for
compile-time optimization guidelines.

- A speed=3 optimization coupled with debug<3 optimization results in
  (attempts to) static-dispatch. This is done using by f-binding
  gentemps to appropriate function objects.
- Inline optimization may also be provided by
  =(declare (inline-pf my-polymorph))= or supplying =:inline t=
  (default) or =:inline :maybe= option in the =name= field of
  =defpolymorph= form.

It is up to the user to ensure that a polymorph that specializes (or
generalizes) another polymorph should have the same behavior, under the
appropriate definition of same-ness.

For instance, consider

#+BEGIN_SRC lisp
  (define-polymorphic-function my-type (obj))
  (defpolymorph my-type ((obj vector)) symbol
    (declare (ignore obj))
    'vector)
  (defpolymorph my-type ((obj string)) symbol
    (declare (ignore obj))
    'string)
#+END_SRC

Then, the behavior of =my-type-caller= depends on optimization policies:

#+BEGIN_SRC lisp
  (defun my-type-caller (a)
    (declare (optimize debug))
    (my-type a))
  (my-type-caller "hello") ;=> STRING

  ;;; VS

  (defun my-type-caller (a)
    (declare (optimize speed)
             (type vector a))
    (my-type a))
  (my-type-caller "hello") ;=> VECTOR
#+END_SRC

The mistake here is polymorph with type list =(vector)= produces a
different behavior as compared to polymorph with type list =(string)=.
(The behavior is "same" in the sense that ="hello"= is indeed a
=vector=; perspective matters?)

This problem also arises with
[[https://github.com/alex-gutev/static-dispatch][static-dispatch]] and
[[https://github.com/guicho271828/inlined-generic-function][inlined-generic-functions]].
The way to avoid it is to either maintain discipline on the part of the
user (the way polymorphic-functions [currently] assumes) or to seal
domains (the way of fast-generic-functions and sealable-metaobjects).

Inlining especially becomes necessary for mathematical operations,
wherein a call to =generic-+= on SBCL can be a 3-10 times slower than
the optimized calls to =fixnum += or =single-float += etc. =generic-cl=
(since =static-dispatch= version 0.5) overcomes this on SBCL by using
=sb-c:deftransform=; for portable projects, one could use
=inlined-generic-functions= [superseded by =fast-generic-functions=]
subject to the limitation that there are no separate classes for (array
single-float) and (array double-float) at least until SBCL 2.1.1.

** Advanced Usage
    :PROPERTIES:
    :CUSTOM_ID: advanced-usage
    :END:

*** Parametric Polymorphism
     :PROPERTIES:
     :CUSTOM_ID: parametric-polymorphism
     :END:

In addition to subtype-polymorphism described above (under
[[#basic-usage][Basic Usage]]), PF also provides support for
parametric-polymorphism. The interface for this is through the following
symbols:

- *parametric-type-symbol-predicates*
- parametric-type-run-time-lambda-body
- parametric-type-compile-time-lambda-body

An example for this is at
[[file:src/extended-types/parametric-types.lisp#L135][src/extended-types/parametric-types.lisp]]
and [[file:src/misc-tests.lisp#L496][src/misc-tests.lisp]].

#+BEGIN_SRC lisp
  CL-USER> (use-package :polymorphic-functions)
  T
  CL-USER> (setq *parametric-type-symbol-predicates*
                 (list (lambda (s)
                         (let* ((name (symbol-name s))
                                (len  (length name)))
                           (and (char= #\< (elt name 0))
                                (char= #\> (elt name (1- len))))))))
  (#<FUNCTION (LAMBDA (S)) {53A475DB}>)

  CL-USER> (defpolymorph foo ((a (array <t>))) <t>
             (aref a 0))
  FOO
  CL-USER> (disassemble (lambda (a)
                          (declare (optimize speed)
                                   (type (simple-array single-float 1) a))
                          (aref a 0)))
  ; disassembly for (LAMBDA (A))
  ; Size: 38 bytes. Origin: #x53A49A5C                          ; (LAMBDA (A))
  ; 5C:       48837AF900       CMP QWORD PTR [RDX-7], 0
  ; 61:       7618             JBE L0
  ; 63:       F30F104201       MOVSS XMM0, [RDX+1]
  ; 68:       660F7EC2         MOVD EDX, XMM0
  ; 6C:       48C1E220         SHL RDX, 32
  ; 70:       80CA19           OR DL, 25
  ; 73:       488BE5           MOV RSP, RBP
  ; 76:       F8               CLC
  ; 77:       5D               POP RBP
  ; 78:       C3               RET
  ; 79:       CC10             INT3 16                          ; Invalid argument count trap
  ; 7B: L0:   CC24             INT3 36                          ; INVALID-VECTOR-INDEX-ERROR
  ; 7D:       08               BYTE #X08                        ; RDX
  ; 7E:       82808010         BYTE #X82, #X80, #X80, #X10      ; 0
  NIL
  CL-USER> (disassemble (lambda (a)
                          (declare (optimize speed)
                                   (type (simple-array single-float 1) a))
                          (foo a)))
  ; disassembly for (LAMBDA (A))
  ; Size: 38 bytes. Origin: #x53A49B0C                          ; (LAMBDA (A))
  ; 0C:       48837AF900       CMP QWORD PTR [RDX-7], 0
  ; 11:       7618             JBE L0
  ; 13:       F30F104201       MOVSS XMM0, [RDX+1]
  ; 18:       660F7EC2         MOVD EDX, XMM0
  ; 1C:       48C1E220         SHL RDX, 32
  ; 20:       80CA19           OR DL, 25
  ; 23:       488BE5           MOV RSP, RBP
  ; 26:       F8               CLC
  ; 27:       5D               POP RBP
  ; 28:       C3               RET
  ; 29:       CC10             INT3 16                          ; Invalid argument count trap
  ; 2B: L0:   CC24             INT3 36                          ; INVALID-VECTOR-INDEX-ERROR
  ; 2D:       08               BYTE #X08                        ; RDX
  ; 2E:       82808010         BYTE #X82, #X80, #X80, #X10      ; 0
  NIL

  CL-USER> (defpolymorph my-add ((a (array <t> (<len>))) (b (array <t> (<len>))))
               (array <t> (<len>))
             (let ((out (make-array <len> :element-type <t>)))
               (loop :for i below <len>
                     :do (setf (aref out i)
                               (+ (aref a i)
                                  (aref b i))))
               out))
  MY-ADD
  CL-USER> (my-add #(0 1) #(1 2)) ; no compilation necessary for usage
  #(1 3)
  CL-USER> (my-add #(0 1) (make-array 2 :element-type 'single-float
                                      :initial-contents '(3.0 4.0)))
  ; Evaluation aborted on #<POLYMORPHIC-FUNCTIONS::NO-APPLICABLE-POLYMORPH/ERROR {1024EB1EA3}>.
  CL-USER> (my-add (make-array 2 :element-type 'single-float
                                 :initial-contents '(3.0 4.0))
                   (make-array 2 :element-type 'single-float
                                 :initial-contents '(3.0 4.0)))
  #(6.0 8.0)
  CL-USER> (type-of *)
  (SIMPLE-ARRAY SINGLE-FLOAT (2))

  ;;; NOTE that the type-parameters cannot be further used in an unevaluated context
  CL-USER> (defpolymorph foo ((a (array <t>))) <t>
             (the <t> (aref a 0)))
  ; WARNING that <T> is an undefined type
#+END_SRC

TODO (perhaps?): Ping/PR [[https://github.com/numcl/gtype][gtype]] for
compile time optimization.

*** Extended Types
     :PROPERTIES:
     :CUSTOM_ID: extended-types
     :END:

=polymorphic-functions.extended-types= package (not system!) provides
types based on [[https://github.com/s-expressionists/ctype][ctype]].
This allows one to extend the CL type system beyond what is possible
with =cl:deftype=.

An example for this is the =(supertypep TYPE)= type at
[[file:src/extended-types/supertypep.lisp]] used in
[[https://github.com/digikar99/trivial-coerce][trivial-coerce]].

- In essence, =(supertypep TYPE)= is the set of all type-specifiers that
  are a supertype of =TYPE=.
- Thus, =(typep 'array '(supertypep vector))= holds.
- In addition, if one were to =(deftype 1d-array () 'vector)= then
  =(typep '1d-array '(supertypep vector))= would also hold.

However, these types can only be used inside the type-lists of
polymorphs or with the shadowed symbols in the
=polymorphic-functions.extended-types= package; they *cannot be used
inside arbitrary CL forms* with =cl:declare=.

** Limitations
    :PROPERTIES:
    :CUSTOM_ID: limitations
    :END:

- For *form-type-inference*, polymorphic-functions depends on
  cl-form-types. Thus, this works as long as cl-form-types succeeds, and
  [[https://github.com/alex-gutev/cl-form-types][cl-form-types]] does
  get pretty extensive. In cases wherein it does fail, we also rely on
  =sb-c:deftransform= on SBCL.
- *Integration with SLIME* is yet to be thought about; etags could work,
  but this needs more thinking given the apparant non-extensibility of
  internals of =slime-edit-definition=. imenu is also another option.
- *ANSI is insufficient* for our purposes: we need
  =introspect-environment:policy-quality= and CLTL2 and more for
  cl-form-types; if someone needs a reduced feature version within the
  bounds of ANSI standard, please raise an issue!

  - Static dispatch relies on policy-quality working as expected, and
    compiler-macros being called. As a result, it may not work on all
    implementations.
  - Some implementations produce interpreted functions some times while
    compiled functions other times; and accordingly differ if or not
    compiler-macros are called.

- A [[https://github.com/Clozure/ccl/pull/369][*bug on CCL*]] may not
  let PF work as correctly on CCL; subjectively dirty workarounds are
  possible until it gets fixed.
- A =polymorphic-functions.extended-types= package (not system!) is also
  provided based on
  [[https://github.com/s-expressionists/ctype][ctype]]. This allows one
  to extend the CL type system to define types beyond what =cl:deftype=
  can do to some extent. While these *cannot be used inside an arbitrary
  CL form* with =cl:declare=, these can be used in the type lists of
  polymorphs. See [[file:src/extended-types/supertypep.lisp]] for an
  example put to use in
  [[https://github.com/digikar99/trivial-coerce][trivial-coerce]].
- Currently *inlining uses the lexical environment of the call-site*
  rather than the definition-site as is the usual case. To work around
  this, users should avoid shadowing global lexical elements.

* Rationale
   :PROPERTIES:
   :CUSTOM_ID: rationale
   :END:

=polymorphic-function= are implemented using the metaclass
=closer-mop:funcallable-standard-class= and
=closer-mop:set-funcallable-instance-function=.

As per
[[http://www.lispworks.com/documentation/HyperSpec/Body/t_generi.htm#generic-function][CLHS]],

#+BEGIN_QUOTE
  A generic function is a function whose behavior depends on the classes
  or identities of the arguments supplied to it.
#+END_QUOTE

By contrast, polymorphic-functions dispatch on the types of the
arguments supplied to it. This helps dispatching on specialized arrays
as well as user-defined types.

In contrast to
[[https://github.com/marcoheisig/sealable-metaobjects][sealable-metaobjects]]
and
[[https://github.com/marcoheisig/fast-generic-functions][fast-generic-functions]],
polymorphic-functions does not make any assumptions about the sealedness
of a domain for purposes of inlining. Thus, users are expected to abide
by the same precautions for inline optimizations here as they do while
inlining normal functions. In particular, users are expected to
recompile their code after additional polymorphs are defined, and also
accordingly manage the compilation order of their files and systems.

IIUC,
[[https://github.com/numcl/specialized-function][specialized-function]]
provides a JIT variant of parametric polymorphism. By contrast, PF
provides an AOT variant.

A related project
[[https://github.com/markcox80/specialization-store][specialization-store]]
also provides support for type-based dispatch:

#+BEGIN_QUOTE
  A premise of specialization store is that all specializations should
  perform the same task. Specializations should only differ in how the
  task is performed. This premise resolves ambiguities that arise when
  using types, rather than classes, to select the most specific
  specialization to apply.
#+END_QUOTE

However, the implications of this assumption are that individual
specializations in each store-object of specialization-store
[[https://github.com/markcox80/specialization-store/wiki/Tutorial-2:-Optional,-Keyword-and-Rest-Arguments][do
not have initializer forms for optional or keyword arguments]].

By contrast, like usual generic-functions, PF does allow initializer
forms for optional and keywords arguments for individual polymorphs.

In addition to being dispatched on types, PF also provides the ability
to install compiler-macros for individual =polymorphs=.

* Dependencies outside quicklisp
   :PROPERTIES:
   :CUSTOM_ID: dependencies-outside-quicklisp
   :END:

- SBCL 2.0.9+
- [[https://github.com/digikar99/trivial-types][trivial-types:function-name]]
- [[https://github.com/alex-gutev/cl-form-types][cl-form-types]]

  - [[https://github.com/alex-gutev/cl-environments][cl-environments]]

- [[https://github.com/digikar99/compiler-macro-notes][compiler-macro-notes]]
- and more... better use ultralisp until then!

** Getting it from ultralisp
    :PROPERTIES:
    :CUSTOM_ID: getting-it-from-ultralisp
    :END:

[[https://ultralisp.org/][Ultralisp]] recently added a feature to allow
[[https://github.com/ultralisp/ultralisp/pull/87][custom dists]]. While
quicklisp will take a while to update trivial-types (and cl-syntax which
several other projects depend upon) to the new repositories since the
originals have been archived and trivial-types is still incomplete wrt
CLHS, we can use the custom dists to distribute this (and related)
libraries.

To do this, add the following to your implementation init file (since
you'll possibly need this to keep with the project updates):

#+BEGIN_SRC lisp
  ;;; An attempt was made to include the enumeration function natively at
  ;;;   https://github.com/quicklisp/quicklisp-client/pull/206
  ;;; but it was rejected, so we do this:
  (defun ql-dist::dist-name-pathname (name)
    "Return the pathname that would be used for an installed dist with
  the given NAME."
    (ql-dist::qmerge (make-pathname :directory (list* :relative "dists"
                                               (uiop:split-string name :separator "/")))))
  (defun digikar99-dist-enumeration-function ()
    "The default function used for producing a list of dist objects."
    (loop for file in (directory (ql-dist::qmerge "dists/digikar99/*/distinfo.txt"))
          collect (ql-dist::make-dist-from-file file)))
  (push 'digikar99-dist-enumeration-function ql::*dist-enumeration-functions*)
#+END_SRC

Once the function is pushed, install the dist:

#+BEGIN_SRC lisp
  ;;; See https://ultralisp.org/dists/digikar99/specialized-array-dispatch for related projects
  (ql-dist:install-dist "http://dist.ultralisp.org/digikar99/specialized-array-dispatch.txt"
                        :prompt nil)
  ;;; If the install-dist step gives a "can't create directory" error, manually
  ;;; create the directory $QUICKLISP_HOME/dists/digikar99
  (ql:update-dist "digikar99/specialized-array-dispatch")
  (ql:quickload "polymorphic-functions")
  (asdf:test-system "polymorphic-functions")
#+END_SRC


** Getting it from clpm

Recently, clpm support was also added.

TODO: Elaborate.
* Tests
   :PROPERTIES:
   :CUSTOM_ID: tests
   :END:

Tests are distributed throughout the system. Run
=(asdf:test-system "polymorphic-functions")=.

* Related Projects
   :PROPERTIES:
   :CUSTOM_ID: related-projects
   :END:

- [[https://github.com/alex-gutev/static-dispatch][static-dispatch]]
- [[https://github.com/markcox80/specialization-store][specialization-store]]
- [[https://github.com/marcoheisig/fast-generic-functions][fast-generic-functions]]
- [[https://github.com/guicho271828/inlined-generic-function][inlined-generic-functions]]
- [[https://github.com/numcl/specialized-function][specialized-function]]
- [[https://github.com/numcl/gtype][gtype]]

* Feature Parity
   :PROPERTIES:
   :CUSTOM_ID: feature-parity
   :END:

The runtime dispatch performance of all the three of
polymorphic-functions, cl:generic-function and specialization-store is
comparable at least for a small number of
polymorphs/methods/specializations.

| Feature                         | cl:generic-function | specialization-store | polymorphic-functions |
|---------------------------------+---------------------+----------------------+-----------------------|
| Method combination              | Yes                 | No                   | No                    |
| Precedence                      | Yes                 | Partial*             | Yes                   |
| &optional, &key, &rest dispatch | No                  | Yes                  | Yes^                  |
| Run-time Speed                  | Fast                | Fast                 | Fast                  |
| Compile-time support            | Partial**           | Yes                  | Yes                   |
| Parametric Polymorphism         | No                  | No                   | Yes                   |

^See [[#comparison-with-specialization-store]]. Well...

**Using
[[https://github.com/marcoheisig/fast-generic-functions][fast-generic-functions]] -
but this apparantly has a few limitations like requiring
non-builtin-classes to have an additional metaclass. This effectively
renders it impossible to use for the classes in already existing
libraries. But, there's also
[[https://github.com/alex-gutev/static-dispatch][static-dispatch]].

* Acknowledgements
   :PROPERTIES:
   :CUSTOM_ID: acknowledgements
   :END:

- [[https://github.com/alex-gutev/][Alex Gutev]] for an extensive
  [[https://github.com/alex-gutev/cl-form-types][cl-form-types]]!
- [[https://github.com/commander-trashdin/][Andrew]] for extensively
  putting polymorphic-functions to test at a brewing project on
  [[https://github.com/lisp-polymorph/][lisp-polymorph]]!
